# JavaScript

<h3> 1. let과 const, 그리고 var </h3>

- let : 블록 스코프 지역 변수를 선언 (추가로 동시에 값을 초기화)
  - var을 대체해서 사용하는 키워드
  - 재할당이 가능하지만, 재선언은 불가능함.
    - 10으로 만든 값을 20으로 바꾸는 것은 가능하지만, 10이라고 정해놓은걸 20이라고 다시 선언하는 것은 불가능.
  - 블록 스코프를 갖는 지역 변수를 선언하고, 선언과 동시에 원하는 값으로 초기화가 가능함.
- const : 블록 스코프 읽기 전용 상수를 선언 (추가로 동시에 값을 초기화)
  - constant : 상수(불변의)
  - 재할당 불가능, 재선언 불가능 : 한 번 만들면 끝!
  - 선언 시 반드시 초기값을 설정해야 하며, 이후에는 값 변경이 불가능함.
  - let 과 동일하게 블록 스코프를 가짐.
- 블록 스코프(block scope) : if, for, 함수 등의 중괄호 `{}` 내부를 가리키며, 블록 스코프를 가지는 변수는 블록 바깥에서 접근이 불가능함. 괄호가 열리고 닫힌 부분을 말함. ‘스코프=범위’ 괄호가 열리고 닫히는 부분에서만 유효.
  - 블록 내에서 선언한 변수는 블록 내에서만 값이 유효함. ➡ 바깥에서 접근 불가능
- var : 변수를 선언 (추가로 동시에 값을 초기화)

  - 재할당 가능, 재선언 가능
  - 함수 스코프(function scope)를 가짐

    - 함수 스코프(function scope) : 함수의 중괄호 `{}` 내부를 가리킴. 함수 스코프를 가지는 변수는 함수 바깥에서 접근이 불가능함.

  - #### ❗ 왜 현재는 JS에서 변수 선언에서 var를 사용하지 않을까?

    #### Hoisting(호이스팅)때문!

    ✅ Hoiting은 var를 사용해 변수 선언을 진행하는 경우, 해당 변수의 선언부를 Scope의 최상단으로 올리는 것을 말한다. JavaScript의 변수 생성과 초기화 작업이 분리되어 진행되기 때문이다.<br> → 이 경우, 변수의 중복선이 가능해지면서 새롭게 변수를 선언하는 경우, 기존의 변수가 다른 값을 가지게 됩니다. 또, for문이 종료되어도 변수에 접근이 가능해지면서 전역 변수가 남발될 수 있다는 문제점이 존재합니다.<br>
    <br>
    ✅ 쉽게 말하면, 변수를 선언 이전에 참조할 수 있는 현상으로 선언 이전에 참조할 수 있고, 변수 선언 이전의 위치에서 접근 시 underfined를 반환함. <br> → 변수를 실제 실행하게 되면,코드의 최상단으로 끌어올려짐. 그래서 var로 선언된 변수는 선언 시에 undefined로 값이 초기화되는 과정이 동시에 일어남. <br> → 변수를 선언하기 이전에 사용한 변수가 에러가 나는게 아니라 차후에 선언한 변수의 값이 할당되는 상황 <br>
    계속 오류가 나는 상황에서 undefined이 나오니까 왜 나오는지 디버깅하기가 힘들었음. 반면, let, const는 호이스팅이 일어나면 에러를 발생시킴. 선언문 오기전에 참조를 먼저하면 에러가 발생함. <br>
    <br>
    ⭐ 기본적으로 사용하는 것은 const, 필요한 경우에만 let을 사용하기, var는 사용하지 말자!⭐<br>

<h3> 2. Array Helper Methods </h3>ㄴ
`map` : `array.map(callback(element[, index[, array]]))` <br>

- 각 배열에 대해서 콜백 함수를 한 번씩 실행하고, 콜백 함수의 반환 값을 요소로 하는 새로운 배열로 반환
- 기존의 배열을 다른 형태로 바꿀 때 유용한 함수
- ex. 기존 배열의 세제곱 수를 구하기

`filter` : `array.filter(callback(element[, index[, array]]))` <br>

- 각 배열에 대해서 콜백 함수를 한 번씩 실행하고, 콜백 함수의 반환 값이 true인 요소들만 모아서 새로운 배열로 반환
- 기존의 배열을 필터링하고 싶을 때 유용한 함수
- ex. 원하는 조건에 맞는 값을 모아 새로운 배열 만들기 -> 장 본 목록 배열에서 과일 종류를 담은 목록만들기

`find` : `array.find(callback(element[, index[, array]]))` <br>

- 각 배열에 대해서 콜백 함수를 한 번씩 실행하고, 콜백 함수의 반환 값이 true면 해당 조건을 만족하는 첫번째 요소를 반환
- 만약, 찾는 값이 배열 안에 없다면 undefined를 반환
- ex. 내가 원하는 사람 이름 찾기

`every`: `array.every(callback(element[, index[, array]]))` <br>

- 배열의 모든 요소가 주어진 판별 함수를 통과하면 true를 반환하고, 하나의 요소라도 통화하지 못하면 false를 반환. 빈 배열은 항상 true로 반환

`some`: `array.some(callback(element[, index[, array]]))` <br>

- 배열의 요소 중 하나라도 주어진 판별 함수를 통과하면 true를 반환하고, 모든 요소가 통과하지 못하면 false가 반환. 빈 배열은 항상 false로 반환
- every보다 좀 더 관대한 메서드!

`reduce`: `array.reduce(callback(acc, element[, index[, array]])[, initialValue])` <br>

- 인자로 주어지는 함수(콜백 함수)를 배열의 각 요소에 대해 한 번씩 실행한 후에 acc에 담아 하나의 값으로 반환
- initialValue는 콜백 함수를 최초로 호출할 때, acc에 담겨 있는 기본 값임. 누적될 값들의 초기값으로, 설정하지 않는 경우 첫번째 요소의 값이 됨.
- 배열을 하나의 값으로 계산하는 동작이 필요할 때 사용하는 메서드이며, map, filter 등 여러 배열 메서드 동작을 대부분 대체할 수 있는 메서드임.
- ex. 배열의 평균, 총합 등의 값을 구하기

<h3> 3. 동기/비동기 </h3>

- 동기: Task 순차 처리. 직렬식 수행
  - 데스크가 돌고, 데이터를 가져오기 위해 일하는 것이고, CPU는 시작시에만 거의 사용됨.
- 비동기: Task 병렬 처리 → 멀티, 싱글 모두 활용 가능함.
  - 보통 CPU가 하는 일이 많은 경우 비동기 가능

<br>

- ❗ 그런데, 비동기코드를 동기식으로 사용해야 하는 경우가 있음.

<h3> 4. `null`과 `undefined`의 가장 대표적인 차이점 </h3>

- Empty Value : 값이 존재하지 않음을 표현하는 값으로 JS에서는 null과 undefined 가 존재함. <br>

  null은 말 그대로 값이 없는 상태이다. 비어있다는 것을 나타내기 위해 사용하는 특별한 키워드라고 생각하는 편이 좋을 것이다. undefined는 값이 할당되지 않은 변수이다. 값이 정의되어 있지 않음을 표현하는 값으로 변수 선언 이후, 직접 값을 할당하지 않은 상황에서 만날 수 있는 키워드이다. <br>
  null 값을 가진다면, undefined 상태는 아니다. 가장 대표적인 차이점은 typeof 연산자를 통해 타입을 확인했을 때 나타난다. null이 원시 타입임에도 불구하고 object로 출력되는 이유는 JS 설계 당시의 버그를 지금까지 해결하지 못한 것이다.

<h3> 5. eval()은 무엇일까? </h3>

- Empty Value : 값이 존재하지 않음을 표현하는 값으로 JS에서는 null과 undefined 가 존재한다. <br>

  eval()은 인자로 받은 코드를 caller의 권한으로 수행하는 함수이다. 악의적인 영향을 받았을 수 있는 문자열을 eval()로 실행한다면, 해당 웹페이지나 확장 프로그램의 권한으로 사용자 기기에서 악의적인 코드를 수행하는 결과를 초래한다. 제 3자코드가 eval()이 호출된 위치의 스코프를 볼 수 있으며, 이를 이용해 비슷한 함수인 Function으로는 실현할 수 없는 공격이 가능해진다.

<h3> 6. append()와 appendChild()의 차이 </h3>

- 각각 조건에 차이가 존재한다. <br>
  append 메서드를 활용하면, 노드 객체(Node object)나 DOMstring(text)를 사용할 수 있으며, 한 번에 여러 개의 자식 요소를 설정할 수 있다. appned 메서드는 return 값을 반환하지 않는다. appendChild 메서드는 오직 Node 객체만을 받을 수 있고, 오직 하나의 노드만 추가할 수 있다. Node가 아닌 값을 넣는 경우, 에러가 발생하고, return 값을 반환한다.
